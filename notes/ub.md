https://zh.cppreference.com/w/cpp/language/ub

C++ 标准为不被归入下列分类之一的每个程序都精确定义了其可观察行为:

* 非良构(ill-formed) -- 程序拥有语法错误或可诊断的语义错误
遵从标准的 C++ 编译器必须为此给出诊断, 即使它定义了为这种代码
赋予了含义的语言扩展(例如用非常量长度数组)也应如此

* 非良构而不要求诊断(ill-formed no diagnostic required) -- 程序
拥有通常情况下可能无法诊断的语义错误(例如 ODR 的违规或者其他只能在链接时检测的错误)
若执行这种程序则行为未定义

* 由实现定义的行为(implementation-defined behavior) -- 程序的行为随实现而变动
遵从标准的实现必须为每个这样的行为的效果提供文档.例如 std::size_t 的类型或字节中的位数
或者 std::bad_alloc::what 的文本.由实现定义的行为的一个子集是本地环境特定
行为(locale-specific behavior), 它取决于实现所提供的本地环境

* 未指明的行为(unspecified behavior) -- 程序的行为随实现而变动, 而不要求遵从标准的实现
为每个行为的效果提供文档.例如求值顺序, 等同的字符串字面量是否为相异对象, 数组分配的开销等等
每个未未指明行为均产生合法结果集合中的一个结果

* 未定义行为(undefined behavior, UB) -- 对程序的行为无任何限制.未定义行为的例子是数组边界外的内存访问
有符号整数溢出, 空指针的解引用, 在无序列点的表达式中多于一次修改同一标量, 通过不同类型的指针访问对象等等
不要求编译器诊断未定义行为(尽管许多简单情形确实会得到诊断), 而且不要求所编译的程序做任何有意义的事

因为正确的 C++ 程序不含未定义行为, 故在启用优化选项以编译确实含有 UB 的程序时, 编译器可能产生不期待的结果
